# example code for graph with vertices 0,1,2 and with following weights
# 0 -> 1: 5
# 0 -> 2: 20
# 1 -> 2: 10

# output should be the following
# from 0 to 0 at cost 0 via vertex 0
# from 0 to 1 at cost 5 via vertex 0
# from 0 to 2 at cost 15 via vertex 1

import sys
import enum
from typing import List, Tuple

import networkx as nx

from oram import OptimalORAM, log2
from dijkstra import convert_graph, dijkstra, test_dijkstra

Edge = Tuple[int, int, int]


def convert_edges_to_oram(
    edges_list: List[Edge],
    edge_index_list: List[int],
    n_loops=None,
    oram_type=OptimalORAM,
    int_type=sint,
):
    # print_ln("Edge List: %s", str(edges_list))
    # print_ln("Edge Index List: %s", str(edge_index_list))
    edges = oram_type(
        len(edges_list),
        entry_size=(log2(len(edge_index_list)), log2(len(edge_index_list)), 1),
        init_rounds=0,
        value_type=int_type.basic_type,
    )
    e_index = oram_type(
        len(edge_index_list),
        entry_size=log2(len(edges_list)),
        value_type=int_type.basic_type,
    )
    for i in range(n_loops or edges.size):
        cint(i).print_reg("edge")
        time()
        edges[i] = edges_list[i]
    vert_loops = n_loops * e_index.size // edges.size if n_loops else e_index.size
    for i in range(vert_loops):
        cint(i).print_reg("vert")
        time()
        e_index[i] = edge_index_list[i]
    return edges, e_index


class MPSPDZTestGraphKind(enum.Enum):
    SIMPLE = "simple"
    KARATE = "karate"
    COMPLETE = "complete"
    CYCLE = "cycle"
    BALANCED_TREE = "balanced_tree"

    @staticmethod
    def generate_graph(
        graph_type: "MPSPDZTestGraphKind", oram_type=OptimalORAM, int_type=sint
    ):
        match graph_type:
            case MPSPDZTestGraphKind.CYCLE:
                G = nx.cycle_graph(7, create_using=nx.DiGraph)
            case MPSPDZTestGraphKind.BALANCED_TREE:
                G = nx.balanced_tree(1, 2, create_using=nx.DiGraph)
            case MPSPDZTestGraphKind.COMPLETE:
                G = nx.complete_graph(7, create_using=nx.DiGraph)
                # for edge in G.edges(data=True):
                #     print_ln("Edge %s", str(edge))
            case MPSPDZTestGraphKind.KARATE:
                G = nx.karate_club_graph()
            case MPSPDZTestGraphKind.SIMPLE | _:
                G = nx.DiGraph()
                G.add_edges_from(
                    [
                        (0, 1, {"weight": 5}),
                        (0, 2, {"weight": 20}),
                        (1, 2, {"weight": 10}),
                        (2, 2, {"weight": 0}),
                    ]
                )
        edges, e_index = convert_edges_to_oram(*convert_graph(G))
        source = int_type(0)
        return source, edges, e_index


def main(graph_type: MPSPDZTestGraphKind):
    print_ln("Generating graph of kind `%s`", str(graph_type))
    source, edges, e_index = MPSPDZTestGraphKind.generate_graph(graph_type)
    print_ln(
        "Generated graph with %s edges and %s vertices. Navigating from vertex %s.",
        edges.size,
        e_index.size,
        source.reveal(),
    )

    res = dijkstra(source, edges, e_index, OptimalORAM, debug=True)

    @for_range(res.size)
    def _(i):
        import util

        print_ln(
            "from %s to %s at cost %s via vertex %s",
            source.reveal(),
            i,
            res[i][0].reveal(),
            res[i][1].reveal(),
        )


# graph_type = MPSPDZTestGraphKind(sys.argv[1]) if len(sys.argv) > 1 else MPSPDZTestGraphKind.SIMPLE
main(MPSPDZTestGraphKind("balanced_tree"))
