# RRT stress test for graph-based MPC RRT algorithm
#
# Tests the RRT algorithm on various graph types.
# Run with:
#   ./build_mpc.sh src/mpc2/rrt_stress_test.mpc
#   ./run_mpc.sh src/mpc2/rrt_stress_test.mpc robot &
#   ./run_mpc.sh src/mpc2/rrt_stress_test.mpc server

import sys
import enum
from typing import List, Tuple

import networkx as nx

from dijkstra import convert_graph
from oram import OptimalORAM, log2
# from types import sint import sint.if_else

Edge = Tuple[int, int, int]

try:
    prog = program.Program.prog
    prog.set_bit_length(min(64, prog.bit_length))
except AttributeError:
    pass

def convert_edges_to_oram(
    edges_list: List[Edge],
    edge_index_list: List[int],
    n_loops=None,
    oram_type=OptimalORAM,
    int_type=sint,
):
    edges = oram_type(
        len(edges_list),
        entry_size=(log2(len(edge_index_list)), log2(len(edge_index_list)), 1),
        init_rounds=0,
        value_type=int_type.basic_type,
    )
    e_index = oram_type(
        len(edge_index_list),
        entry_size=log2(len(edges_list)),
        value_type=int_type.basic_type,
    )
    for i in range(n_loops or edges.size):
        cint(i).print_reg("edge")
        time()
        edges[i] = edges_list[i]
    vert_loops = n_loops * e_index.size // edges.size if n_loops else e_index.size
    for i in range(vert_loops):
        cint(i).print_reg("vert")
        time()
        e_index[i] = edge_index_list[i]
    return edges, e_index


def rrt(
    source,
    goal,
    edges,
    e_index,
    oram_type,
    max_iterations=None,
    int_type=None,
    debug=False,
):
    """Securely compute RRT (Rapidly-exploring Random Tree) on a secret graph.

    Grows a random tree from source through existing graph edges until
    goal is reached or max_iterations is exhausted. Uses the same graph
    representation as :py:func:`dijkstra`.

    :param source: source node (secret or clear-text integer)
    :param goal: goal node (secret or clear-text integer)
    :param edges: ORAM representation of edges
    :param e_index: ORAM representation of vertices
    :param oram_type: ORAM type to use internally
    :param max_iterations: when to stop (default: number of edges)
    :param int_type: secret integer type (default: sint)
    :param debug: print debug output

    :returns: (parent ORAM, goal_reached flag)
    """
    n_vertices = e_index.size
    n_edges = edges.size
    if max_iterations is None:
        max_iterations = n_edges

    # Parent ORAM: vertex -> parent_vertex
    # init_rounds=-1 ensures all entries start as empty (not in tree)
    parent = oram_type(
        n_vertices, entry_size=log2(n_vertices), init_rounds=-1, value_type=int_type
    )
    int_type = parent.value_type
    basic_type = int_type.basic_type

    # Initialize: source is in tree, parent of source is itself
    parent[source] = source

    goal_reached = MemValue(basic_type(0))

    # Number of bits for random vertex sampling
    v_bits = log2(n_vertices)

    @for_range(max_iterations)
    def rrt_iter(iteration):
        if debug:
            print_ln("rrt loop %s", iteration)
            time()

        # 1. Sample random vertex with ~12.5% goal bias
        bias = sint.get_random_int(3)
        use_goal = bias == 0
        v_rand_raw = sint.get_random_int(v_bits)
        v_rand = sint.if_else(use_goal, basic_type(goal), basic_type(v_rand_raw))

        # 2. Check if v_rand is already in tree
        _, v_rand_empty = parent.read(v_rand)
        # v_rand_empty = 1 means NOT in tree (candidate for exact extension)

        # 3. Scan all edges to find best tree extension
        #    Exact: tree vertex u with edge to v_rand (v_rand not in tree)
        #    Fallback: any tree vertex u with edge to non-tree vertex v
        current_u = MemValue(basic_type(0))

        found_exact = MemValue(basic_type(0))
        exact_u = MemValue(basic_type(0))

        found_fallback = MemValue(basic_type(0))
        fallback_u = MemValue(basic_type(0))
        fallback_v = MemValue(basic_type(0))

        @for_range(n_edges)
        def scan_edges(ei):
            dest, weight, le = edges[ei]

            # Check if source vertex (current_u) is in tree
            _, u_empty = parent.read(current_u)
            u_in_tree = 1 - u_empty

            # Check if dest vertex is NOT in tree
            _, d_empty = parent.read(dest)
            d_not_in_tree = d_empty

            # Valid extension: source in tree, dest not in tree
            valid_ext = u_in_tree * d_not_in_tree

            # Exact match: valid AND dest == v_rand AND v_rand not yet in tree
            is_exact = valid_ext * (dest == v_rand) * v_rand_empty
            is_exact *= 1 - found_exact
            exact_u.write(sint.if_else(is_exact, current_u, exact_u))
            found_exact.write(sint.if_else(is_exact, basic_type(1), found_exact))

            # Fallback: valid extension, no exact or fallback found yet
            is_fb = valid_ext * (1 - found_exact) * (1 - found_fallback)
            fallback_u.write(sint.if_else(is_fb, current_u, fallback_u))
            fallback_v.write(sint.if_else(is_fb, dest, fallback_v))
            found_fallback.write(sint.if_else(is_fb, basic_type(1), found_fallback))

            # Advance source vertex when last_edge bit is set
            current_u.write(current_u + basic_type(le))

        # 4. Choose extension: prefer exact match over fallback
        new_parent = sint.if_else(found_exact, exact_u, fallback_u)
        new_child = sint.if_else(found_exact, v_rand, fallback_v)
        found_any = found_exact + found_fallback - found_exact * found_fallback
        should_add = found_any * (1 - goal_reached)

        # 5. Conditionally add new_child to tree with new_parent
        parent.access(new_child, new_parent, should_add)

        # 6. Check if goal was just reached
        child_is_goal = new_child == goal
        just_reached = child_is_goal * should_add
        goal_reached.write(goal_reached + just_reached - goal_reached * just_reached)

        if debug:
            print_ln(
                "  v_rand=%s, found_exact=%s, found_fb=%s, "
                "new_child=%s, new_parent=%s, should_add=%s, "
                "goal_reached=%s",
                v_rand.reveal(),
                found_exact.reveal(),
                found_fallback.reveal(),
                new_child.reveal(),
                new_parent.reveal(),
                should_add.reveal(),
                goal_reached.reveal(),
            )

    return parent, goal_reached


class MPSPDZTestGraphKind(enum.Enum):
    SIMPLE = "simple"
    KARATE = "karate"
    COMPLETE = "complete"
    CYCLE = "cycle"
    BALANCED_TREE = "balanced_tree"

    @staticmethod
    def generate_graph(
        graph_type: "MPSPDZTestGraphKind", oram_type=OptimalORAM, int_type=sint
    ):
        match graph_type:
            case MPSPDZTestGraphKind.CYCLE:
                G = nx.cycle_graph(32, create_using=nx.DiGraph)
                goal = int_type(16)
            case MPSPDZTestGraphKind.BALANCED_TREE:
                G = nx.balanced_tree(1, 2, create_using=nx.DiGraph)
                goal = int_type(3)
            case MPSPDZTestGraphKind.COMPLETE:
                G = nx.complete_graph(6, create_using=nx.DiGraph)
                # for edge in G.edges(data=True):
                #     print_ln("Edge %s", str(edge))
                goal = int_type(3)
            case MPSPDZTestGraphKind.KARATE:
                G = nx.karate_club_graph()
                goal = int_type(33)
            case MPSPDZTestGraphKind.SIMPLE | _:
                G = nx.DiGraph()
                G.add_edges_from(
                    [
                        (0, 1, {"weight": 5}),
                        (0, 2, {"weight": 20}),
                        (1, 2, {"weight": 10}),
                        (2, 2, {"weight": 0}),
                    ]
                )
                goal = int_type(2)

        edges, e_index = convert_edges_to_oram(
            *convert_graph(G), oram_type=oram_type, int_type=int_type
        )
        source = int_type(0)
        return source, goal, edges, e_index


# TODO: Adapt runner when moving this alg to its own library file.
# def run_rrt(graph_size: GraphSize):
#     match graph_size:
#         case GraphSize.SIMPLE | _:
#             source, edges, e_index = generate_simple_graph()
#
#     goal = sint(e_index.size - 1)
#     print_ln('RRT from vertex %s to vertex %s', source.reveal(), goal.reveal())
#
#     parent, goal_reached = rrt(source, goal, edges, e_index, OptimalORAM,
#                                debug=True)
#
#     print_ln('Goal reached: %s', goal_reached.reveal())
#
#     @for_range(e_index.size)
#     def _(i):
#         pv, not_in_tree = parent.read(i)
#         print_ln('vertex %s: parent=%s (in_tree=%s)',
#                  i, pv[0].reveal(), (1 - not_in_tree).reveal())


def main(graph_type: MPSPDZTestGraphKind):
    print_ln("Generating graph of kind `%s` for RRT", str(graph_type))
    source, goal, edges, e_index = MPSPDZTestGraphKind.generate_graph(graph_type)
    print_ln("Generated graph with %s edges and %s vertices.", edges.size, e_index.size)
    print_ln("RRT from vertex %s to vertex %s", source.reveal(), goal.reveal())

    parent, goal_reached = rrt(source, goal, edges, e_index, OptimalORAM, debug=True)

    print_ln("Goal reached: %s", goal_reached.reveal())

    @for_range(e_index.size)
    def _(i):
        pv, not_in_tree = parent.read(i)
        print_ln(
            "vertex %s: parent=%s (in_tree=%s)",
            i,
            pv[0].reveal(),
            (1 - not_in_tree).reveal(),
        )


# graph_type = MPSPDZTestGraphKind(sys.argv[1]) if len(sys.argv) > 1 else MPSPDZTestGraphKind.SIMPLE
main(MPSPDZTestGraphKind("complete"))
